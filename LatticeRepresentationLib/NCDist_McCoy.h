//
//  CNCDist.c
//
//
//  Created by Herbert J. Bernstein on 3/26/13.
//
//
// Edited for optimizations by Airlie J. McCoy 11/2025
#ifndef NCDIST_H_MCCOLL
#define NCDIST_H_MCCOLL

/* The projectors for the 15 base types (5-D boundaries
 in G6), plus a few extra for internal boundaries
 Note that the array indices are swapped from the
 Fortan versions */

#include <float.h>
#include <math.h>
#include <cstring>
#include <algorithm>
#include <array>
#include <atomic>
#include <cfloat>
#include <cmath>
#include <vector>

//#define HAS_XSIMD
#ifdef HAS_XSIMD
#include <xsimd/xsimd.hpp>
#endif
namespace phasertng {
/* Basic counts for boundaries / projectors */
constexpr int NBND = 15;

constexpr int P_1 = 0;
constexpr int P_2 = 1;
constexpr int P_3 = 2;
constexpr int P_4 = 3;
constexpr int P_5 = 4;
constexpr int P_6 = 5;
constexpr int P_7 = 6;
constexpr int P_8 = 7;
constexpr int P_9 = 8;
constexpr int P_A = 9;
constexpr int P_B = 10;
constexpr int P_C = 11;
constexpr int P_D = 12;
constexpr int P_E = 13;
constexpr int P_F = 14;
constexpr int P_6C = 15;
constexpr int P_67 = 16;
constexpr int P_9A = 17;
constexpr int P_CD = 18;
constexpr int P_12 = 19;
constexpr int P_8B = 20;
constexpr int P_8E = 21;
constexpr int P_8F = 22;
constexpr int P_BF = 23;
constexpr int P_EF = 24;
constexpr int P_28F = 25;
constexpr int P_2BF = 26;
constexpr int P_2EF = 27;
constexpr int P_269 = 28;
constexpr int P_26C = 29;
constexpr int P_2F = 30;
constexpr int P_27 = 31;
constexpr int P_2A = 32;
constexpr int P_2D = 33;
constexpr int P_28E = 34;
constexpr int P_28B = 35;

constexpr int NBDPRJ = 36;

/*                                                          . . . . . . . . . .
 * . . . . . . . . . . .*/
/*                              1 2 3 4 5 6 7 8 9 A B C D E F C 7 A D 2 B E F F
 * F F F F 9 C F 7 A D E B*/

constexpr int ispbd[NBDPRJ] = {1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
                                           1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0,
                                           0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0};
constexpr int ismbd[NBDPRJ] = {1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0,
                                           0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
                                           1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1};
constexpr int ispmappedbd[NBND] = {1, 1, 1, 1, 1, 0, 1, 1,
                                               0, 1, 1, 0, 1, 1, 0};
constexpr int ismmappedbd[NBND] = {1, 1, 1, 1, 1, 1, 0, 0,
                                               1, 0, 0, 1, 0, 0, 1};
constexpr int pmmappedbd[NBND] = {0,  1,  2,  3,  4,  7,  -1, -1,
                                              10, -1, -1, 13, -1, -1, -1};
constexpr int mpmappedbd[NBND] = {0,  1, 2, 3,  4,  -1, -1, -1,
                                              -1, 8, 9, -1, 12, 13, 14};

/* The projector names: */
constexpr const char*  prjnames[NBDPRJ] = {
    "P_1",  "P_2",   "P_3",   "P_4",   "P_5",   "P_6",   "P_7",  "P_8",
    "P_9",  "P_A",   "P_B",   "P_C",   "P_D",   "P_E",   "P_F",  "P_6C",
    "P_67", "P_9A",  "P_CD",  "P_12",  "P_8B",  "P_8E",  "P_8F", "P_BF",
    "P_EF", "P_28F", "P_2BF", "P_2EF", "P_269", "P_26C", "P_2F", "P_27",
    "P_2A", "P_2D",  "P_28E", "P_28B"};

constexpr double THIRD = 0.3333333333333333;
constexpr double TWOTHD = 0.6666666666666667;
constexpr double TWOTHI = 0.6666666666666666;

/* Boundary projectors */
constexpr double prj[NBDPRJ][NBDPRJ] = {
     /*prj[P-1]   1 */
     {0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_2]   2 */
     {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0,
      0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_3]   3 */
     {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_4]   4 */
     {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_5]   5 */
     {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
     /*prj[P_6]   6 */
     {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_7]   7 */
     {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_8]  8 */
     {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5,  0.0, -0.5, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.5,  0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,  0.0, 0.0,  0.0, 1.0},
     /*prj[P_9]   9 */
     {0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_A]   A */
     {0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1},
     /*prj[P_B]  B */
     {0.5,  0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0,  0.0, 1.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      -0.5, 0.0, 0.0, 0.0, 0.5,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_C]  C */
     {0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /*prj[P_D]  D */
     {0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /*prj[P_E]  E */
     {0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0,  1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0,  0.0,  0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0,  -0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /*prj[P_F]  F */
     {0.8,  -0.2, 0.0, -0.2, -0.2, -0.2, -0.2, 0.8,  0.0, -0.2, -0.2, -0.2,
      0.0,  0.0,  1.0, 0.0,  0.0,  0.0,  -0.2, -0.2, 0.0, 0.8,  -0.2, -0.2,
      -0.2, -0.2, 0.0, -0.2, 0.8,  -0.2, -0.2, -0.2, 0.0, -0.2, -0.2, 0.8},
     /*prj[P_6C]  g4=g2, g6=g1 */
     {0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /*prj[P_67]  67 */
     {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5},
     /*prj[P_9A]  9A */
     {0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5,
      0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5},
     /*prj[P_CD]  CD */
     {0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0,
      0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /*prj[P_12]  12 g1=g2=g3 */
     {THIRD, THIRD, THIRD, 0.0, 0.0, 0.0, THIRD, THIRD, THIRD, 0.0, 0.0, 0.0,
      THIRD, THIRD, THIRD, 0.0, 0.0, 0.0, 0.0,   0.0,   0.0,   1.0, 0.0, 0.0,
      0.0,   0.0,   0.0,   0.0, 1.0, 0.0, 0.0,   0.0,   0.0,   0.0, 0.0, 1.0},
     /*prj[P_8B]  8B g4=-g2, g5=-g1*/
     {0.5,  0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.5,  0.0, -0.5, 0.0, 0.0,
      0.0,  0.0, 1.0, 0.0, 0.0,  0.0, 0.0, -0.5, 0.0, 0.5,  0.0, 0.0,
      -0.5, 0.0, 0.0, 0.0, 0.5,  0.0, 0.0, 0.0,  0.0, 0.0,  0.0, 1.0},
     /*prj[P_8E]  8E g4=-g2, g6=-g1*/
     {0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0,  0.5,  0.0, -0.5, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0,  0.0,  -0.5, 0.0, 0.5,  0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0,  -0.5, 0.0,  0.0, 0.0,  0.0, 0.5},
     /*prj[P_8F]  8F g4=-g2, g1+g2+g4+g5+g6 = 0 */
     {TWOTHD, 0.0,    0.0,    0.0,    -THIRD, -THIRD, 0.0,    0.5,    0.0,
      -0.5,   0.0,    0.0,    0.0,    0.0,    1.0,    0.0,    0.0,    0.0,
      0.0,    -0.5,   0.0,    0.5,    0.0,    0.0,    -THIRD, 0.0,    0.0,
      0.0,    TWOTHD, -THIRD, -THIRD, 0.0,    0.0,    0.0,    -THIRD, TWOTHD},
     /*prj[P_BF]  BF g5=-g1, g1+g2+g4+g5+g6 = 0 */
     {0.5,  0.0, 0.0, 0.0, -0.5, 0.0, 0.0, TWOTHD, 0.0, -THIRD, 0.0, -THIRD,
      0.0,  0.0, 1.0, 0.0, 0.0,  0.0, 0.0, -THIRD, 0.0, TWOTHD, 0.0, -THIRD,
      -0.5, 0.0, 0.0, 0.0, 0.5,  0.0, 0.0, -THIRD, 0.0, -THIRD, 0.0, TWOTHD},
     /*prj[P_EF]  EF g6=-g1, g1+g2+g4+g5+g6 = 0 */
     {0.5,    0.0,    0.0, 0.0,    0.0,    -0.5, 0.0, TWOTHD, 0.0,
      -THIRD, -THIRD, 0.0, 0.0,    0.0,    1.0,  0.0, 0.0,    0.0,
      0.0,    -THIRD, 0.0, TWOTHD, -THIRD, 0.0,  0.0, -THIRD, 0.0,
      -THIRD, TWOTHD, 0.0, -0.5,   0.0,    0.0,  0.0, 0.0,    0.5},
     /*prj[P_28F]  28F g2=g3, g4=-g2, g1+g5+g6 = 0 */
     {TWOTHD, 0.0,    0.0,    0.0,    -THIRD, -THIRD, 0.0,    THIRD,  THIRD,
      -THIRD, 0.0,    0.0,    0.0,    THIRD,  THIRD,  -THIRD, 0.0,    0.0,
      0.0,    -THIRD, -THIRD, THIRD,  0.0,    0.0,    -THIRD, 0.0,    0.0,
      0.0,    TWOTHI, -THIRD, -THIRD, 0.0,    0.0,    0.0,    -THIRD, TWOTHD},
     /*prj[P_2BF]  2BF g2=g3, g5=-g1, g2+g4+g6 = 0 */
     {0.5,  0.0, 0.0, 0.0,  -0.5, 0.0,  0.0, 0.4,  0.4,  -0.2, 0.0, -0.2,
      0.0,  0.4, 0.4, -0.2, 0.0,  -0.2, 0.0, -0.2, -0.2, 0.6,  0.0, -0.4,
      -0.5, 0.0, 0.0, 0.0,  0.5,  0.0,  0.0, -0.2, -0.2, -0.4, 0.0, 0.6},
     /*prj[P_2EF] 2EF g2=g3, g6=-g1, g2+g4+g5=0  */
     {0.5, 0.0,  0.0,  0.0,  0.0,  -0.5, 0.0,  0.4,  0.4,  -0.2, -0.2, 0.0,
      0.0, 0.4,  0.4,  -0.2, -0.2, 0.0,  0.0,  -0.2, -0.2, 0.6,  -0.4, 0.0,
      0.0, -0.2, -0.2, -0.4, 0.6,  0.0,  -0.5, 0.0,  0.0,  0.0,  0.0,  0.5},
     /*prj[P_269] 269 g2=g3=g4, g1=g5  */
     {0.5, 0.0,   0.0,   0.0,   0.5, 0.0, 0.0, THIRD, THIRD, THIRD, 0.0, 0.0,
      0.0, THIRD, THIRD, THIRD, 0.0, 0.0, 0.0, THIRD, THIRD, THIRD, 0.0, 0.0,
      0.5, 0.0,   0.0,   0.0,   0.5, 0.0, 0.0, 0.0,   0.0,   0.0,   0.0, 1.0},
     /*prj[P_26C] 26C g2=g3=g4 g1=g6  */
     {0.5, 0.0,   0.0,   0.0,   0.0, 0.5, 0.0, THIRD, THIRD, THIRD, 0.0, 0.0,
      0.0, THIRD, THIRD, THIRD, 0.0, 0.0, 0.0, THIRD, THIRD, THIRD, 0.0, 0.0,
      0.0, 0.0,   0.0,   0.0,   1.0, 0.0, 0.5, 0.0,   0.0,   0.0,   0.0, 0.5},
     /*prj[P_2F] 2F g2=g3, g1+g2+g4+g5+g6 = 0 */
     {.7777777777777778,  -.1111111111111111, -.1111111111111111,
      -.2222222222222222, -.2222222222222222, -.2222222222222222,
      -.1111111111111111, .4444444444444444,  .4444444444444444,
      -.1111111111111111, -.1111111111111111, -.1111111111111111,
      -.1111111111111111, .4444444444444444,  .4444444444444444,
      -.1111111111111111, -.1111111111111111, -.1111111111111111,
      -.2222222222222222, -.1111111111111111, -.1111111111111111,
      .7777777777777778,  -.2222222222222222, -.2222222222222222,
      -.2222222222222222, -.1111111111111111, -.1111111111111111,
      -.2222222222222222, .7777777777777778,  -.2222222222222222,
      -.2222222222222222, -.1111111111111111, -.1111111111111111,
      -.2222222222222222, -.2222222222222222, .7777777777777778},
     /*prj[P_27] 27  g2=g3=g4 */
     {1.0, 0.0,   0.0,   0.0,   0.0, 0.0, 0.0, THIRD, THIRD, THIRD, 0.0, 0.0,
      0.0, THIRD, THIRD, THIRD, 0.0, 0.0, 0.0, THIRD, THIRD, THIRD, 0.0, 0.0,
      0.0, 0.0,   0.0,   0.0,   1.0, 0.0, 0.0, 0.0,   0.0,   0.0,   0.0, 1.0},
     /*prj[P_2A] 2A g1=g5, g2=g3 */
     {0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0,
      0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /*prj[P_2D] 2D g1=g6, g2=g3 */
     {0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0,
      0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /*prj[P_28E] 17 g1=-g6, g2=g3=-g4 */
     {0.5,    0.0,    0.0,    0.0,   0.0,   -0.5,  0.0,    THIRD, THIRD,
      -THIRD, 0.0,    0.0,    0.0,   THIRD, THIRD, -THIRD, 0.0,   0.0,
      0.0,    -THIRD, -THIRD, THIRD, 0.0,   0.0,   0.0,    0.0,   0.0,
      0.0,    1.0,    0.0,    -0.5,  0.0,   0.0,   0.0,    0.0,   0.5},
     /*prj[P_28B] 1A g1=-g5, g2=g3=-g4 */
     {0.5,    0.0,    0.0,    0.0,   -0.5,  0.0,   0.0,    THIRD, THIRD,
      -THIRD, 0.0,    0.0,    0.0,   THIRD, THIRD, -THIRD, 0.0,   0.0,
      0.0,    -THIRD, -THIRD, THIRD, 0.0,   0.0,   -0.5,   0.0,   0.0,
      0.0,    0.5,    0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   1.0}
};

/* Perps of the boundary projectors */
constexpr double prjperp[NBDPRJ][NBDPRJ] = {
     /* 1 */
     {0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0},
     /* 2 */
     {0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.5, -0.5, 0.0, 0.0, 0.0,
      0.0, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0,
      0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0},
     /* 3 */
     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
     /* 4 */
     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
     /* 5 */
     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
     /* 6 */
     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5,  0.0, -0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.5,  0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0,  0.0, 0.0},
     /* 7 */
     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5,  0.0, -0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.5,  0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0,  0.0, 0.0},
     /* 8 */
     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
     /* 9 */
     {0.5,  0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0,  0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      -0.5, 0.0, 0.0, 0.0, 0.5,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
     /* A */
     {0.5,  0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0,  0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      -0.5, 0.0, 0.0, 0.0, 0.5,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
     /* B */
     {0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
     /* C */
     {0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0,  0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  -0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /* D */
     {0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0,  0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  -0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /* E */
     {0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /* F */
     {0.2, 0.2, 0.0, 0.2, 0.2, 0.2, 0.2, 0.2, 0.0, 0.2, 0.2, 0.2,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.2, 0.0, 0.2, 0.2, 0.2,
      0.2, 0.2, 0.0, 0.2, 0.2, 0.2, 0.2, 0.2, 0.0, 0.2, 0.2, 0.2},
     /*prj[P_6C]  g4=g2, g6=g1 */
     {0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0,  0.5,  0.0, -0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0,  -0.5, 0.0, 0.5,  0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  -0.5, 0.0,  0.0, 0.0,  0.0, 0.5},
     /* 67 */
     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.5,  0.0, -0.5, 0.0,  0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0, -0.5, 0.0, 0.5,  0.0,  0.0,
      0.0, 0.0, 0.0, 0.0, 0.5, -0.5, 0.0, 0.0,  0.0, 0.0,  -0.5, 0.5},
     /* 9A */
     {0.5,  0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0,
      0.0,  0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.5,  0.0, -0.5,
      -0.5, 0.0, 0.0, 0.0, 0.5,  0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.5},
     /* CD */
     {0.5, 0.0, 0.0, 0.0,  0.0, -0.5, 0.0,  0.0, 0.0, 0.0, 0.0,  0.0,
      0.0, 0.0, 0.0, 0.0,  0.0, 0.0,  0.0,  0.0, 0.0, 0.5, -0.5, 0.0,
      0.0, 0.0, 0.0, -0.5, 0.5, 0.0,  -0.5, 0.0, 0.0, 0.0, 0.0,  0.5},
     /* 12 g1=g2=g3 */
     {TWOTHD, -THIRD, -THIRD, 0.0,    0.0,    0.0,    -THIRD, TWOTHD, -THIRD,
      0.0,    0.0,    0.0,    -THIRD, -THIRD, TWOTHD, 0.0,    0.0,    0.0,
      0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
      0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0},
     /*prjperp[P_8B]  8B g4=-g2, g5=-g1*/
     {0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
     /*prjperp[P_8E]  8E g4=-g2, g6=-g1*/
     {0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5},
     /* 8F g4=-g2, g1+g2+g4+g5+g6 = 0 */
     {THIRD, 0.0, 0.0, 0.0, THIRD, THIRD, 0.0,   0.5, 0.0, 0.5, 0.0,   0.0,
      0.0,   0.0, 0.0, 0.0, 0.0,   0.0,   0.0,   0.5, 0.0, 0.5, 0.0,   0.0,
      THIRD, 0.0, 0.0, 0.0, THIRD, THIRD, THIRD, 0.0, 0.0, 0.0, THIRD, THIRD},
     /* BF BF g5=-g1, g1+g2+g4+g5+g6 = 0 */
     {0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, THIRD, 0.0, THIRD, 0.0, THIRD,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, THIRD, 0.0, THIRD, 0.0, THIRD,
      0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, THIRD, 0.0, THIRD, 0.0, THIRD},
     /* EF g6=-g1.0, g1+g2+g4+g5+g6 = 0 */
     {0.5, 0.0,   0.0, 0.0,   0.0,   0.5, 0.0, THIRD, 0.0, THIRD, THIRD, 0.0,
      0.0, 0.0,   0.0, 0.0,   0.0,   0.0, 0.0, THIRD, 0.0, THIRD, THIRD, 0.0,
      0.0, THIRD, 0.0, THIRD, THIRD, 0.0, 0.5, 0.0,   0.0, 0.0,   0.0,   0.5},
     /*prjperp[P_28F]  28F g2=g3, g4=-g2, g1+g5+g6 = 0 */
     {THIRD, 0.0,   0.0,   0.0,    THIRD,  THIRD,  0.0,   TWOTHD, -THIRD,
      THIRD, 0.0,   0.0,   0.0,    -THIRD, TWOTHD, THIRD, 0.0,    0.0,
      0.0,   THIRD, THIRD, TWOTHD, 0.0,    0.0,    THIRD, 0.0,    0.0,
      0.0,   THIRD, THIRD, THIRD,  0.0,    0.0,    0.0,   THIRD,  THIRD},
     /*prjperp[P_2BF] 2BF g2=g3, g5=-g1, g2+g4+g6 = 0 */
     {0.5, 0.0,  0.0, 0.0, 0.5, 0.0, 0.0, 0.6, -0.4, 0.2, 0.0, 0.2,
      0.0, -0.4, 0.6, 0.2, 0.0, 0.2, 0.0, 0.2, 0.2,  0.4, 0.0, 0.4,
      0.5, 0.0,  0.0, 0.0, 0.5, 0.0, 0.0, 0.2, 0.2,  0.4, 0.0, 0.4},
     /*prjperp[P_2EF] 2EF g2=g3, g6=-g1, g2+g4+g5=0  */
     {0.5, 0.0,  0.0, 0.0, 0.0, 0.5, 0.0, 0.6, -0.4, 0.2, 0.2, 0.0,
      0.0, -0.4, 0.6, 0.2, 0.2, 0.0, 0.0, 0.2, 0.2,  0.4, 0.4, 0.0,
      0.0, 0.2,  0.2, 0.4, 0.4, 0.0, 0.5, 0.0, 0.0,  0.0, 0.0, 0.5},
     /*prjperp[P_269] 269 g2=g3=g4, g1=g5  */
     {0.5,    0.0,    0.0,    0.0,    -0.5,   0.0,    0.0,    TWOTHD, -THIRD,
      -THIRD, 0.0,    0.0,    0.0,    -THIRD, TWOTHD, -THIRD, 0.0,    0.0,
      0.0,    -THIRD, -THIRD, TWOTHD, 0.0,    0.0,    -0.5,   0.0,    0.0,
      0.0,    0.5,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0},
     /*prjperp[P_26C] 26C g2=g3=g4 g1=g6  */
     {0.5,    0.0,    0.0,    0.0,    0.0,    -0.5,   0.0,    TWOTHI, -THIRD,
      -THIRD, 0.0,    0.0,    0.0,    -THIRD, TWOTHI, -THIRD, 0.0,    0.0,
      0.0,    -THIRD, -THIRD, TWOTHI, 0.0,    0.0,    0.0,    0.0,    0.0,
      0.0,    0.0,    0.0,    -0.5,   0.0,    0.0,    0.0,    0.0,    0.5},
     /*prjperp[P_2F] 2F g2=g3, g1+g2+g4+g5+g6 = 0 */
     {.2222222222222222, .1111111111111111,  .1111111111111111,
      .2222222222222222, .2222222222222222,  .2222222222222222,
      .1111111111111111, .5555555555555556,  -.4444444444444444,
      .1111111111111111, .1111111111111111,  .1111111111111111,
      .1111111111111111, -.4444444444444444, .5555555555555556,
      .1111111111111111, .1111111111111111,  .1111111111111111,
      .2222222222222222, .1111111111111111,  .1111111111111111,
      .2222222222222222, .2222222222222222,  .2222222222222222,
      .2222222222222222, .1111111111111111,  .1111111111111111,
      .2222222222222222, .2222222222222222,  .2222222222222222,
      .2222222222222222, .1111111111111111,  .1111111111111111,
      .2222222222222222, .2222222222222222,  .2222222222222222},
     /*prjperp[P_27] 27 g2=g3=g4 */
     {0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    TWOTHD, -THIRD,
      -THIRD, 0.0,    0.0,    0.0,    -THIRD, TWOTHD, -THIRD, 0.0,    0.0,
      0.0,    -THIRD, -THIRD, TWOTHD, 0.0,    0.0,    0.0,    0.0,    0.0,
      0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0},
     /*prjperp[P_2A] 2A g1=g5, g2=g3 */
     {0.5,  0.0,  0.0, 0.0, -0.5, 0.0, 0.0, 0.5, -0.5, 0.0, 0.0, 0.0,
      0.0,  -0.5, 0.5, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0,
      -0.5, 0.0,  0.0, 0.0, 0.5,  0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0},
     /*prjperp[P_2D] 2D g1=g6, g2=g3 */
     {0.5, 0.0,  0.0, 0.0, 0.0, -0.5, 0.0,  0.5, -0.5, 0.0, 0.0, 0.0,
      0.0, -0.5, 0.5, 0.0, 0.0, 0.0,  0.0,  0.0, 0.0,  0.0, 0.0, 0.0,
      0.0, 0.0,  0.0, 0.0, 0.0, 0.0,  -0.5, 0.0, 0.0,  0.0, 0.0, 0.5},
     /*prjperp[P_28E] 17 g1=-g6, g2=g3=-g4 */
     {0.5,   0.0,   0.0,   0.0,    0.0,    0.5,    0.0,   TWOTHI, -THIRD,
      THIRD, 0.0,   0.0,   0.0,    -THIRD, TWOTHI, THIRD, 0.0,    0.0,
      0.0,   THIRD, THIRD, TWOTHI, 0.0,    0.0,    0.0,   0.0,    0.0,
      0.0,   0.0,   0.0,   0.5,    0.0,    0.0,    0.0,   0.0,    0.5},
     /*prjperp[P_28F] 1A g1=-g5, g2=g3=-g4 */
     {0.5,   0.0,   0.0,   0.0,    0.5,    0.0,    0.0,   TWOTHI, -THIRD,
      THIRD, 0.0,   0.0,   0.0,    -THIRD, TWOTHI, THIRD, 0.0,    0.0,
      0.0,   THIRD, THIRD, TWOTHI, 0.0,    0.0,    0.5,   0.0,    0.0,
      0.0,   0.5,   0.0,   0.0,    0.0,    0.0,    0.0,   0.0,    0.0}
  };

/* The following matrices are the transformation
 matrices that may be applied at the associated
 boundaries  */

constexpr int MS[NBND][NBDPRJ] = {

    /* M_1 (g1 = g2, a -> b, b -> a) */
    {0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
      0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},

    /* M_2 (g2 = g3, b -> c, c -> b) */
    {1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
      0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0},

    /* M_3 (g4 = 0, a -> -a) */
    {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,
      0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, -1},

    /* M_4 (g5 = 0, b -> -b) */
    {1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
      0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1},

    /* M_5 (g6 = 0, c -> -c) */
    {1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,
      0, 0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1},

    /* M_6 (g2 = g4, g5 >= g6, b -> -b, c -> b - c) */
    {1, 0,  0, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0, 1, 1, -1, 0, 0,
      0, -2, 0, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0,  0, -1},

    /* M_7 (g2 = g4, g5 < g6, c -> b - c) */
    {1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,  0, 0, 1, 1, -1, 0, 0,
      0, 2, 0, -1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0,  0, 1},

    /* M_8 (g2 = -g4, a -> -a, c -> b + c) */
    {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0,  0, 1, 1, 1, 0, 0,
      0, 2, 0, 1, 0, 0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, -1},

    /* M_9 (g1 = g5, g4 >= g6, b -> -b, c -> c - a) */
    {1, 0, 0, 0,  0, 0, 0,  1, 0, 0, 0, 0, 1, 0, 1, 0, -1, 0,
      0, 0, 0, -1, 0, 1, -2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  -1},

    /* M_A (g1 = g5, g4 < g6, c -> a - c) */
    {1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,  0, 1, 0, 1, 0, -1, 0,
      0, 0, 0, -1, 0, 1, 2, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0,  1},

    /* M_B (g1 = -g5, b -> -b, c -> a + c) */
    {1, 0, 0, 0,  0, 0,  0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0,
      0, 0, 0, -1, 0, -1, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1},

    /* M_C (g1 = g6, g4 >= g5, b -> -b, b -> b - a) */
    {1, 0, 0, 0,  0, 0, 1, 1, 0, 0, 0,  -1, 0,  0, 1, 0, 0, 0,
      0, 0, 0, -1, 1, 0, 0, 0, 0, 0, -1, 0,  -2, 0, 0, 0, 0, 1},

    /* M_D (g1 = g6, g4 < g5, b -> a - b) */
    {1, 0, 0, 0,  0, 0, 1, 1, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0,
      0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 1, 0,  2, 0, 0, 0, 0, -1},

    /* M_E (g1 = -g6, b -> a + b, c -> -c ) */
    {1, 0, 0, 0,  0,  0, 1, 1, 0, 0, 0,  1, 0, 0, 1, 0, 0, 0,
      0, 0, 0, -1, -1, 0, 0, 0, 0, 0, -1, 0, 2, 0, 0, 0, 0, 1},

    /* M_F (g1+g2+g3+g4+g5+g6 = g3, c -> -(a+b+c)) */
    {1, 0,  0, 0,  0, 0,  0,  1, 0, 0, 0,  0,  1, 1, 1, 1, 1, 1,
      0, -2, 0, -1, 0, -1, -2, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, 1}

};

/* The 24 elements of the group of reflections generated by M_1, M_2,
   M_3, M_4 and M_5 */

constexpr int NREFL = 24;

constexpr int rord[NREFL] = {0,  1,  2,  3,  4,  5,  9,  12,
                                         14, 19, 15, 13, 20, 6,  8,  10,
                                         11, 16, 17, 18, 21, 22, 23, 7};

constexpr int RS[NREFL][NBDPRJ] = {
     /*  R_0:M_ident;     */
     {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
       0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1},
     /*  R_1:M_1;         */
     {0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
       0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},
     /*  R_2:M_2;         */
     {1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
       0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0},
     /*  R_3:M_2.M_1;     */
     {0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0},
     /*  R_4:M_1.M_2;     */
     {0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
     /*  R_5:M_2.M_1.M_2; */
     {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0},
     /*  R_6:M_3.R_0;     */
     {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,
       0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, -1},
     /*  R_7:M_3.R_1;     */
     {0, 1, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0, 0, 0, 1, 0, 0, 0,
       0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1},
     /*  R_8:M_3.R_2;     */
     {1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0, 1, 0, 0, 0,  0,
       0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0},
     /*  R_9:M_3.R_3;     */
     {0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  1, 0, 0, 0,  0, 0,
       0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0},
     /*  R_10:M_3.R_4;    */
     {0, 0, 1, 0, 0, 0, 1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,  0,
       0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0},
     /*  R_11:M_3.R_5;    */
     {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0,  0, 1, 0, 0, 0,  0, 0,
       0, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0},
     /*  R_12:M_4.R_0;    */
     {1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
       0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1},
     /*  R_13:M_4.R_1;    */
     {0, 1, 0, 0, 0,  0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
       0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1},
     /*  R_14:M_4.R_2;    */
     {1, 0, 0, 0,  0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0,  0,
       0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0},
     /*  R_15:M_4.R_3;    */
     {0, 1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,  0, 0,
       0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0},
     /*  R_16:M_4.R_4;    */
     {0, 0, 1, 0, 0, 0,  1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0,
       0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, 0},
     /*  R_17:M_4.R_5;    */
     {0, 0, 1, 0, 0, 0,  0, 1, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0,
       0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0},
     /*  R_18:M_5.R_0;    */
     {1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,
       0, 0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1},
     /*  R_19:M_5.R_1;    */
     {0, 1, 0, 0, 0,  0, 1, 0, 0, 0,  0, 0, 0, 0, 1, 0, 0, 0,
       0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 1},
     /*  R_20:M_5.R_2;    */
     {1, 0, 0, 0,  0, 0, 0, 0, 1, 0, 0, 0,  0, 1, 0, 0, 0, 0,
       0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0},
     /*  R_21:M_5.R_3;    */
     {0, 1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0,  1, 0, 0, 0, 0, 0,
       0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0},
     /*  R_22:M_5.R_4;    */
     {0, 0, 1, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 1, 0, 0, 0, 0,
       0, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1, 0},
     /*  R_23:M_5.R_5;    */
     {0, 0, 1, 0, 0, 0,  0, 1, 0, 0, 0,  0, 1, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0}

    };

constexpr int baseord[NBND] = {0, 1, 2,  3,  4,  5,  5, 7,
                                           8, 8, 10, 11, 11, 13, 14};
constexpr int mapord[NBND] = {0,  1, 2, 3,  4,  7,  6, 5,
                                          10, 9, 8, 13, 12, 11, 14};

/*     Test for being in the unrolled Niggli cone */

inline int isunc(const double v[6])
{
  const double fz = 1.0e-7;

  if (v[0] < 0.0 || v[1] < 0.0 || v[2] < 0.0) return 0;

  double maxedge = (v[0] < v[1]) ? v[1] : v[0];
  if (v[2] > maxedge) maxedge = v[2];

  if (v[3] > v[1] + maxedge * fz || v[3] > v[2] + maxedge * fz ||
      v[4] > v[0] + maxedge * fz || v[4] > v[1] + maxedge * fz ||
      v[5] > v[0] + maxedge * fz || v[5] > v[1] + maxedge * fz ||
      v[3] < -v[1] - maxedge * fz || v[3] < -v[2] - maxedge * fz ||
      v[4] < -v[0] - maxedge * fz || v[4] < -v[1] - maxedge * fz ||
      v[5] < -v[0] - maxedge * fz || v[5] < -v[1] - maxedge * fz)
    return 0;

  const double s0 = v[0] + v[1] + v[2];
  const double s1 = s0 + v[3] + v[4] + v[5];
  const double s2 = s0 + v[3] - v[4] - v[5];
  const double s3 = s0 - v[3] + v[4] - v[5];
  const double s4 = s0 - v[3] - v[4] + v[5];

  if (s1 < maxedge * (1.0 - fz)) return 0;
  if (s2 < maxedge * (1.0 - fz)) return 0;
  if (s3 < maxedge * (1.0 - fz)) return 0;
  if (s4 < maxedge * (1.0 - fz)) return 0;

  return 1;
}

constexpr double EPS_SIGN = 1e-38;   // sign test threshold
constexpr double EPS_DIFF = 1e-12;   // diff comparison threshold
constexpr double EPS_CHANGE = 1e-8;  // debug change threshold

constexpr double INV_SQRT2 = 0.70710678118654752440084436210484903928;
constexpr double INV_SQRT5 = 0.44721359549995793928183473374625524709;

/* Test a vector component for being pos or neg */

inline int CNCM_ctop(double comp) { return (comp > -EPS_SIGN ? 1 : -1); }
inline int CNCM_ctom(double comp) { return (comp < EPS_SIGN ? -1 : 1); }

/* Test a vector for being +++ or ---
   vtoppp(v) returns +1 for a vector in +++ or on its boundary
   vtommm(v) returns -1 for a vector in --- or on its boundary

   Note that there is an overlap in these tests on the boundary
 */
inline int CNCM_vtoppp(const double v[6])
{
  return CNCM_ctop(v[3]) * CNCM_ctop(v[4]) * CNCM_ctop(v[5]);
}
inline int CNCM_vtommm(const double v[6])
{
  return CNCM_ctom(v[3]) * CNCM_ctom(v[4]) * CNCM_ctom(v[5]);
}

/*     Compute the best distance between 2 G6 vectors
 allowing for cell-preserving sign changes in
 g4,5,6
 */

inline double g456distsq(const double v1[6], const double v2[6])
{
  // Differences
  const double d0 = v1[0] - v2[0];
  const double d1 = v1[1] - v2[1];
  const double d2 = v1[2] - v2[2];
  const double d3 = v1[3] - v2[3];
  const double d4 = v1[4] - v2[4];
  const double d5 = v1[5] - v2[5];

  // Squared Euclidean distance
  double dist = d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3 + d4 * d4 + d5 * d5;

  // Products needed for correction term
  const double p33 = v1[3] * v2[3];
  const double p44 = v1[4] * v2[4];
  const double p55 = v1[5] * v2[5];

  // Compute the 3 candidates
  const double c1 = p33 + p44;
  const double c2 = p33 + p55;
  const double c3 = p44 + p55;

  // Compute the min(0, c1, c2, c3)
  double extra = 0.0;
  extra = std::min(extra, c1);
  extra = std::min(extra, c2);
  extra = std::min(extra, c3);

  return dist + 4.0 * extra;
}

inline double g456dist(const double v1[6], const double v2[6])
{
  return std::sqrt(g456distsq(v1, v2));
}

/* Macro versions of distances */

inline double CNCM_normsq(const double v[6])
{
  return v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3] + v[4] * v[4] +
         v[5] * v[5];
}

inline double CNCM_norm(const double v[6]) { return sqrt(CNCM_normsq(v)); }

inline double CNCM_gdistsq(const double v1[6], const double v2[6])
{
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]) +
         (v1[2] - v2[2]) * (v1[2] - v2[2]) + (v1[3] - v2[3]) * (v1[3] - v2[3]) +
         (v1[4] - v2[4]) * (v1[4] - v2[4]) + (v1[5] - v2[5]) * (v1[5] - v2[5]);
}

inline double CNCM_gdist(const double v1[6], const double v2[6])
{
  return sqrt(CNCM_gdistsq(v1, v2));
}

/* Compute the gdist distance when moving between +++ and --- */

inline double CNCM_gpmdistsq(const double v1[6], const double v2[6])
{
  // Check all signs at once with bitwise operations
  const bool v1_pos = (v1[3] > -1e-38) & (v1[4] > -1e-38) & (v1[5] > -1e-38);
  const bool v1_neg = (v1[3] < 1e-38) & (v1[4] < 1e-38) & (v1[5] < 1e-38);
  const bool v2_pos = (v2[3] > -1e-38) & (v2[4] > -1e-38) & (v2[5] > -1e-38);
  const bool v2_neg = (v2[3] < 1e-38) & (v2[4] < 1e-38) & (v2[5] < 1e-38);

  if ((v1_pos & v2_pos) | (v1_neg & v2_neg))
  {
    return CNCM_gdistsq(v1, v2);
  }

  // Compute base terms once
  const double dx = v1[0] - v2[0], dy = v1[1] - v2[1], dz = v1[2] - v2[2];
  const double d012 = dx * dx + dy * dy + dz * dz;

  const double v13_sq = v1[3] * v1[3], v23_sq = v2[3] * v2[3];
  const double v14_sq = v1[4] * v1[4], v24_sq = v2[4] * v2[4];
  const double v15_sq = v1[5] * v1[5], v25_sq = v2[5] * v2[5];

  const double v13v23 = v1[3] * v2[3];
  const double v14v24 = v1[4] * v2[4];
  const double v15v25 = v1[5] * v2[5];

  const double t0 = std::fabs(v13v23) - v14v24 - v15v25;
  const double t1 = -v13v23 + std::fabs(v14v24) - v15v25;
  const double t2 = -v13v23 - v14v24 + std::fabs(v15v25);

  const double mix =
      2.0 * std::min({std::fabs(t0), std::fabs(t1), std::fabs(t2)});

  return d012 + v13_sq + v23_sq + v14_sq + v24_sq + v15_sq + v25_sq + mix;
}

inline double CNCM_gpmdist(const double v1[6], const double v2[6])
{
  return sqrt(CNCM_gpmdistsq(v1, v2));
}

inline double CNCM_gtestdist(const double v1[6], const double v2[6])
{
  return CNCM_gpmdist(v1, v2);
}

inline double CNCM_gtestdistsq(const double v1[6], const double v2[6])
{
  return CNCM_gpmdistsq(v1, v2);
}

#ifdef HAS_XSIMD
inline double guncpmdistsq(const double v1[6], const double v2[6])
{
    using batch = xsimd::batch<double>;
    constexpr std::size_t W = batch::size;

    batch acc = batch(0.0);    // Accumulate squared differences
    std::size_t i = 0;

    // --- Vectorized portion: process in chunks of W that fit inside 6 ---
    for (; i + W <= 6; i += W)
    {
        batch a = batch::load_unaligned(v1 + i);
        batch b = batch::load_unaligned(v2 + i);
        batch d = a - b;
        acc += d * d;
    }

    // --- Reduce the SIMD accumulator ---
    alignas(64) double buf[W];
    acc.store_aligned(buf);

    double xdot = 0.0;
    for (std::size_t k = 0; k < W; ++k)
        xdot += buf[k];

    // --- Scalar tail for leftover elements (or everything if W > 6) ---
    for (; i < 6; ++i)
    {
        double d = v1[i] - v2[i];
        xdot += d * d;
    }

    // --- Correction term (unchanged from your original) ---
    const double p33 = v1[3] * v2[3];
    const double p44 = v1[4] * v2[4];
    const double p55 = v1[5] * v2[5];

    const double t1 = p33 + p44;
    const double t2 = p33 + p55;
    const double t3 = p44 + p55;

    const double extra = std::min(std::min(std::min(0.0, t1), t2), t3);

    return xdot + 4.0 * extra;
}
#else
inline double guncpmdistsq(const double v1[6], const double v2[6])
{
  const double* plusvec = nullptr;
  const double* minusvec = nullptr;

  double d6, d8, d9, dB, dC, dE;
  double p6[6], p8[6], p9[6], pB[6], pC[6], pE[6];
  double mp6[6], mp8[6], mp9[6], mpB[6], mpC[6], mpE[6];

  double dist68sq, dist9Bsq, distCEsq, distsq, dist;

  const int v1_ppp = CNCM_vtoppp(v1);
  const int v1_mmm = CNCM_vtommm(v1);
  const int v2_ppp = CNCM_vtoppp(v2);
  const int v2_mmm = CNCM_vtommm(v2);

  if (!isunc(v1) || !isunc(v2)) return CNCM_gdistsq(v1, v2);

  if (v1_ppp * v2_ppp > 0 && v1_mmm * v2_mmm > 0)
    return CNCM_gtestdistsq(v1, v2);

  // select plusvec/minusvec
  if (v1_ppp < 0 || v1_mmm < 0)
  {
    plusvec = v2;
    minusvec = v1;
  }
  else
  {
    plusvec = v1;
    minusvec = v2;
  }

  double plus[6];
  double minus[6];
  std::memcpy(plus,  plusvec,  6 * sizeof(double));
  std::memcpy(minus, minusvec, 6 * sizeof(double));

  distsq = CNCM_gtestdistsq(plus, minus);

  // tunnel distances
  const double rsqrt2 = INV_SQRT2;
  d6 = std::fabs(plus[3] - plus[1]) * rsqrt2;
  d8 = std::fabs(minus[3] + minus[1]) * rsqrt2;
  d9 = std::fabs(plus[4] - plus[0]) * rsqrt2;
  dB = std::fabs(minus[4] + minus[0]) * rsqrt2;
  dC = std::fabs(plus[5] - plus[0]) * rsqrt2;
  dE = std::fabs(minus[5] + minus[0]) * rsqrt2;

  // p6/mp6
  {
    const double a = (plus[3] + plus[1]) * 0.5;

    p6[0] = plus[0];
    p6[1] = a;
    p6[2] = plus[2];
    p6[3] = a;
    p6[4] = plus[4];
    p6[5] = plus[5];

    mp6[0] = plus[0];
    mp6[1] = a;
    mp6[2] = plus[2];
    mp6[3] = -a;
    mp6[4] = plus[5] - plus[4];
    mp6[5] = -plus[5];
  }

  // p8/mp8
  {
    const double a = (minus[3] - minus[1]) * 0.5;

    p8[0] = minus[0];
    p8[1] = -a;
    p8[2] = minus[2];
    p8[3] = a;
    p8[4] = minus[4];
    p8[5] = minus[5];

    mp8[0] = minus[0];
    mp8[1] = -a;
    mp8[2] = minus[2];
    mp8[3] = -a;
    mp8[4] = -minus[5] - minus[4];
    mp8[5] = -minus[5];
  }

  // p9/mp9
  {
    const double a = 0.5 * (plus[4] + plus[0]);

    p9[0] = a;
    p9[1] = plus[1];
    p9[2] = plus[2];
    p9[3] = plus[3];
    p9[4] = a;
    p9[5] = plus[5];

    mp9[0] = a;
    mp9[1] = plus[1];
    mp9[2] = plus[2];
    mp9[3] = plus[5] - plus[3];
    mp9[4] = -a;
    mp9[5] = -plus[5];
  }

  // pB/mpB
  {
    const double a = 0.5 * (minus[4] - minus[0]);

    pB[0] = -a;
    pB[1] = minus[1];
    pB[2] = minus[2];
    pB[3] = minus[3];
    pB[4] = a;
    pB[5] = minus[5];

    mpB[0] = -a;
    mpB[1] = minus[1];
    mpB[2] = minus[2];
    mpB[3] = -minus[5] - minus[3];
    mpB[4] = -a;
    mpB[5] = -minus[5];
  }

  // pC/mpC
  {
    const double a = 0.5 * (plus[5] + plus[0]);

    pC[0] = a;
    pC[1] = plus[1];
    pC[2] = plus[2];
    pC[3] = plus[3];
    pC[4] = plus[4];
    pC[5] = a;

    mpC[0] = a;
    mpC[1] = plus[1];
    mpC[2] = plus[2];
    mpC[3] = plus[4] - plus[3];
    mpC[4] = -plus[4];
    mpC[5] = -a;
  }

  // pE/mpE
  {
    const double a = 0.5 * (minus[5] - minus[0]);

    pE[0] = -a;
    pE[1] = minus[1];
    pE[2] = minus[2];
    pE[3] = minus[3];
    pE[4] = minus[4];
    pE[5] = a;

    mpE[0] = -a;
    mpE[1] = minus[1];
    mpE[2] = minus[2];
    mpE[3] = -minus[4] - minus[3];
    mpE[4] = -minus[4];
    mpE[5] = -a;
  }

  // path tests
  dist = d6 + CNCM_gtestdist(mp6, minus);
  dist = std::min(dist, d9 + CNCM_gtestdist(mp9, minus));
  dist = std::min(dist, dC + CNCM_gtestdist(mpC, minus));
  dist = std::min(dist, d8 + CNCM_gtestdist(mp8, plus));
  dist = std::min(dist, dB + CNCM_gtestdist(mpB, plus));
  dist = std::min(dist, dE + CNCM_gtestdist(mpE, plus));
  distsq = std::min(distsq, dist * dist);

  // 6–8 tunnel
  dist68sq = CNCM_gtestdistsq(p6, p8);
  dist68sq = std::min(dist68sq, CNCM_gtestdistsq(p6, mp8));
  dist68sq = std::min(dist68sq, CNCM_gtestdistsq(mp6, p8));
  dist68sq = std::min(dist68sq, CNCM_gtestdistsq(mp6, mp8));
  dist68sq += (d6 + d8) * (d6 + d8);
  if (dist68sq < distsq) distsq = dist68sq;

  // 9–B tunnel
  dist9Bsq = CNCM_gtestdistsq(p9, pB);
  dist9Bsq = std::min(dist9Bsq, CNCM_gtestdistsq(p9, mpB));
  dist9Bsq = std::min(dist9Bsq, CNCM_gtestdistsq(mp9, pB));
  dist9Bsq = std::min(dist9Bsq, CNCM_gtestdistsq(mp9, mpB));
  dist9Bsq += (d9 + dB) * (d9 + dB);
  if (dist9Bsq < distsq) distsq = dist9Bsq;

  // C–E tunnel
  distCEsq = CNCM_gtestdistsq(pC, pE);
  distCEsq = std::min(distCEsq, CNCM_gtestdistsq(pC, mpE));
  distCEsq = std::min(distCEsq, CNCM_gtestdistsq(mpC, pE));
  distCEsq = std::min(distCEsq, CNCM_gtestdistsq(mpC, mpE));
  distCEsq += (dC + dE) * (dC + dE);
  if (distCEsq < distsq) distsq = distCEsq;

  return distsq;
}
#endif

inline double guncpmdist(const double v1[6], const double v2[6])
{
  return std::sqrt(guncpmdistsq(v1, v2));
}

#ifdef HAS_SIMD
inline void rmv6(const double v1[6], const double m[36],double v2[6])
{
    using batch = xsimd::batch<double>;

    // Load vector v1 into SIMD batches
    const batch a0 = batch(v1[0]);
    const batch a1 = batch(v1[1]);
    const batch a2 = batch(v1[2]);
    const batch a3 = batch(v1[3]);
    const batch a4 = batch(v1[4]);
    const batch a5 = batch(v1[5]);

    // We’ll compute 6 rows. Each row is 6 FMA operations.
    for (int r = 0; r < 6; ++r)
    {
        const double* mm = &m[r * 6];

        // Load the 6 coefficients (scalar → SIMD broadcast)
        batch mr0(mm[0]), mr1(mm[1]), mr2(mm[2]);
        batch mr3(mm[3]), mr4(mm[4]), mr5(mm[5]);

        // SIMD FMA chain:
        batch acc = mr0 * a0;
        acc       = xsimd::fma(mr1, a1, acc);
        acc       = xsimd::fma(mr2, a2, acc);
        acc       = xsimd::fma(mr3, a3, acc);
        acc       = xsimd::fma(mr4, a4, acc);
        acc       = xsimd::fma(mr5, a5, acc);

        // Horizontal sum for this row
        v2[r] = xsimd::reduce_add(acc);
    }
}
#else
inline void rmv6(const double v1[6], const double m[36],double v2[6])
{
  for (int i = 0; i < 6; ++i)
  {
    const int rowIndex = 6 * i;
    double sum = 0.0;
    sum += m[rowIndex + 0] * v1[0];
    sum += m[rowIndex + 1] * v1[1];
    sum += m[rowIndex + 2] * v1[2];
    sum += m[rowIndex + 3] * v1[3];
    sum += m[rowIndex + 4] * v1[4];
    sum += m[rowIndex + 5] * v1[5];
    v2[i] = sum;
  }
}
#endif

#ifdef HAS_SIMD
//the SIMD function handles ints automatically because they get promoted to double inside the batch constructor.
inline void imv6(const double v1[6], const int m[36], double v2[6])
{
    // Convert integer matrix -> double matrix (one cheap loop)
    double md[NBDPRJ];
    for (int i = 0; i < NBDPRJ; ++i) md[i] = static_cast<double>(m[i]);

    // Now safe to call SIMD rmv6
    rmv6(v1, md, v2);
}
#else
inline void imv6(const double v1[6], const int m[36], double v2[6])
{
  // Load v1 into locals (avoid repeated v1[i] loads)
  const double a0 = v1[0];
  const double a1 = v1[1];
  const double a2 = v1[2];
  const double a3 = v1[3];
  const double a4 = v1[4];
  const double a5 = v1[5];

  // Row 0
  v2[0] = m[0] * a0 + m[1] * a1 + m[2] * a2 + m[3] * a3 + m[4] * a4 + m[5] * a5;

  // Row 1
  v2[1] =
      m[6] * a0 + m[7] * a1 + m[8] * a2 + m[9] * a3 + m[10] * a4 + m[11] * a5;

  // Row 2
  v2[2] = m[12] * a0 + m[13] * a1 + m[14] * a2 + m[15] * a3 + m[16] * a4 +
          m[17] * a5;

  // Row 3
  v2[3] = m[18] * a0 + m[19] * a1 + m[20] * a2 + m[21] * a3 + m[22] * a4 +
          m[23] * a5;

  // Row 4
  v2[4] = m[24] * a0 + m[25] * a1 + m[26] * a2 + m[27] * a3 + m[28] * a4 +
          m[29] * a5;

  // Row 5
  v2[5] = m[30] * a0 + m[31] * a1 + m[32] * a2 + m[33] * a3 + m[34] * a4 +
          m[35] * a5;
}
#endif

#ifdef HAS_SIMD
inline void twoPminusI(const double pg[6], const double g[6], double gout[6])
{
    using batch = xsimd::batch<double>;

    batch a0 = batch::load_unaligned(&pg[0]);
    batch b0 = batch::load_unaligned(&g[0]);

    batch r0 = (a0 + a0) - b0;     // 2*pg[0..3] - g[0..3]
    r0.store_unaligned(&gout[0]);

    gout[4] = 2*pg[4] - g[4];
    gout[5] = 2*pg[5] - g[5];
}
#else
inline void twoPminusI(const double pg[6], const double g[6], double gout[6])
{
  for (int i = 0; i < 6; ++i) gout[i] = 2.0 * pg[i] - g[i];
}
#endif


/*     Map a G6 vector onto the boundaries after
       applying the 24-way unfolding */
#define NCDIST_NO_OUTER_PASS_MCCOLL * /
#ifdef NCDIST_NO_OUTER_PASS_MCCOLL
constexpr int NREFL_OUTER_FULL = 8;
constexpr int NREFL_OUTER_MIN = 1;
#else
constexpr int NREFL_OUTER_FULL = 24;
constexpr int NREFL_OUTER_MIN = 6;
#endif

inline double bddist(const double gvec[6], int bdnum)
{
  double bdin = 1.0;
  const double rsqrt2 = INV_SQRT2;

  if (bdnum < NBND)
  {
    // First switch: handle conditions that set bdin to -1.0
    double diffval(0);
    switch (bdnum)
    {
      case P_2:
        diffval = gvec[1] - gvec[2];
        if (diffval > 0) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_3:
        if (gvec[3] > 0.0) bdin = -1.0;
        return bdin * std::fabs(gvec[3]);
      case P_4:
        if (gvec[4] > 0.0) bdin = -1.0;
        return bdin * std::fabs(gvec[4]);
      case P_5:
        if (gvec[5] > 0.0) bdin = -1.0;
        return bdin * std::fabs(gvec[5]);
      case P_1:
        diffval = gvec[0] - gvec[1];
        if (diffval > 0) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_6:
        diffval = gvec[3] - gvec[1];
        if (diffval > 0) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_7:
        diffval = gvec[3] - gvec[1];
        if (diffval > 0) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_8:
        diffval = -gvec[3] - gvec[1];
        if (diffval > 0) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_9:
        diffval = gvec[4] - gvec[0];
        if (diffval) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_A:
        diffval = gvec[4] - gvec[0];
        if (diffval) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_B:
        diffval = -gvec[4] - gvec[0];
        if (diffval) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_C:
        diffval = gvec[5] - gvec[0];
        if (diffval) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_D:
        diffval = gvec[5] - gvec[0];
        if (diffval) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_E:
        diffval = -gvec[5] - gvec[0];
        if (diffval) bdin = -1.0;
        return bdin * std::fabs(diffval) * rsqrt2;
      case P_F:
        diffval = gvec[0] + gvec[1] + gvec[3] + gvec[4] + gvec[5];
        if (diffval < 0.0) bdin = -1.0;
        return bdin * std::fabs(diffval) * INV_SQRT5;
      default:
        break;
    }
  }

  return DBL_MAX;
}

/* Get the minimum distance to the diagonals boundaries */

inline double minbddist(const double gvec[6])
{
  const double rsqrt2 = INV_SQRT2;

  double dists[4];

  // group 1: differences between g1,g2,g3
  dists[0] = std::min(std::min(std::fabs(gvec[1] - gvec[0]),
                               std::fabs(gvec[2] - gvec[1])),
                      std::fabs(gvec[2] - gvec[0])) *
             rsqrt2;

  // group 2: |g4|,|g5|,|g6|
  dists[1] = std::min(std::min(std::fabs(gvec[3]), std::fabs(gvec[4])),
                      std::fabs(gvec[5]));

  // group 3: mixed inequalities with abs(g4..g6)
  double t = std::min(std::min(std::fabs(gvec[1] - std::fabs(gvec[3])),
                               std::fabs(gvec[0] - std::fabs(gvec[4]))),
                      std::fabs(gvec[0] - std::fabs(gvec[5])));
  t = std::min(t, std::fabs(gvec[1] - std::fabs(gvec[5])));
  t = std::min(std::min(t, std::fabs(gvec[2] - std::fabs(gvec[4]))),
               std::fabs(gvec[2] - std::fabs(gvec[3])));
  dists[2] = t * rsqrt2;

  // group 4: four different sum/difference combos
  const double s01 = gvec[0] + gvec[1];
  double u = std::fabs(s01 + gvec[3] + gvec[4] + gvec[5]);
  u = std::min(u, std::fabs(s01 - gvec[3] - gvec[4] + gvec[5]));
  u = std::min(u, std::fabs(s01 - gvec[3] + gvec[4] - gvec[5]));
  u = std::min(u, std::fabs(s01 + gvec[3] - gvec[4] - gvec[5]));
  dists[3] = u * INV_SQRT5;

  double minbd = dists[0];
  minbd = std::min(minbd, dists[1]);
  minbd = std::min(minbd, dists[2]);
  minbd = std::min(minbd, dists[3]);

  return minbd;
}

inline void bdmaps(const double gvec[6], 
   double dists[NBND],
   int iord[NBND],
   double pgs[NBND][6],
   double rgs[NBND][6],
   double mpgs[NBND][6],
   double mvecs[NBND][6],
   double maxdist,
   int *ngood)
{
  // 1) Compute all boundary distances (reusing expressions)
  const double rsqrt2 = INV_SQRT2;

  const double d10 = std::fabs(gvec[1] - gvec[0]) * rsqrt2;
  const double d21 = std::fabs(gvec[2] - gvec[1]) * rsqrt2;
  const double d3 = std::fabs(gvec[3]);
  const double d4 = std::fabs(gvec[4]);
  const double d5 = std::fabs(gvec[5]);
  const double d13 = std::fabs(gvec[1] - gvec[3]) * rsqrt2;
  const double d1p3 = std::fabs(gvec[1] + gvec[3]) * rsqrt2;
  const double d04 = std::fabs(gvec[0] - gvec[4]) * rsqrt2;
  const double d0p4 = std::fabs(gvec[0] + gvec[4]) * rsqrt2;
  const double d05 = std::fabs(gvec[0] - gvec[5]) * rsqrt2;
  const double d0p5 = std::fabs(gvec[0] + gvec[5]) * rsqrt2;
  const double dF =
      std::fabs(gvec[0] + gvec[1] + gvec[3] + gvec[4] + gvec[5]) * INV_SQRT5;

  // NOTE: P_* are assumed to be in [0, NBND)
  dists[P_1] = d10;
  dists[P_2] = d21;
  dists[P_3] = d3;
  dists[P_4] = d4;
  dists[P_5] = d5;
  dists[P_6] = d13;
  dists[P_7] = d13;  // same expression as P_6
  dists[P_8] = d1p3;
  dists[P_9] = d04;
  dists[P_A] = d04;  // same expression as P_9
  dists[P_B] = d0p4;
  dists[P_C] = d05;
  dists[P_D] = d05;  // same expression as P_C
  dists[P_E] = d0p5;
  // We have NBND = 15; if P_F is outside [0,14], it's not part of NBND.
  // If P_F is inside [0,14], include it:
#if defined(P_F)
#if P_F >= 0 && P_F < NBND
  dists[P_F] = dF;
#endif
#endif

  // 2) Initialize ordering to 0..NBND-1
  for (int j = 0; j < NBND; ++j)
  {
    iord[j] = j;
  }

  // 3) Insertion sort iord by dists[iord[*]] (NBND is tiny: 15)
  for (int k = 1; k < NBND; ++k)
  {
    int key = iord[k];
    double dkey = dists[key];
    int j = k - 1;

    // Move larger elements one step to the right
    while (j >= 0 && dists[iord[j]] > dkey)
    {
      iord[j + 1] = iord[j];
      --j;
    }
    iord[j + 1] = key;
  }

  // 4) Determine how many boundaries are within maxdist
  //    and ONLY compute pgs/rgs/mpgs/mvecs for those.
  int good = 0;
  for (; good < NBND; ++good)
  {
    if (dists[iord[good]] > maxdist) break;
  }
  *ngood = good;

  // 5) Precompute projected / reflected / mapped vectors ONLY for good ones
  for (int jx = 0; jx < good; ++jx)
  {
    const int j = iord[jx];

    rmv6(gvec, prj[j], pgs[j]);        // projection to boundary j
    twoPminusI(pgs[j], gvec, rgs[j]);  // reflected gvec across boundary j
    imv6(pgs[j], MS[j], mpgs[j]);      // mapped projected
    imv6(gvec, MS[j], mvecs[j]);       // mapped original
  }

  // Entries beyond *ngood in pgs/rgs/mpgs/mvecs are left uninitialised;
  // they are never accessed because callers only iterate jx < *ngood.
}

inline double NCDist_2bds(const double gvec1[6], const double rgvec1[6],
                          const double pg1[6],  const double mpg1[6], int bd1,
                          const double gvec2[6], const double rgvec2[6],
                          const double pg2[6],  const double mpg2[6], int bd2,
                          double dist)
{
    // Reject if any vector is outside the Niggli cone
    if (!isunc(gvec1) || !isunc(gvec2) ||
        !isunc(pg1)   || !isunc(pg2)   ||
        !isunc(mpg1)  || !isunc(mpg2))
        return dist;

    // -------- Precompute boundary distances we will need --------
    // Primary boundaries
    const double d11_0 = bddist(gvec1, bd1);
    const double d22_0 = bddist(gvec2, bd2);

    // "Cross" boundaries for the initial combination
    double d12_0 = d11_0;
    double d21_0 = d22_0;
    if (baseord[bd1] != baseord[bd2]) {
        d12_0 = bddist(gvec1, bd2);
        d21_0 = bddist(gvec2, bd1);
    }

    // Reflected versions (these are reused in multiple sign cases)
    const double d12_rg1_bd2 = bddist(rgvec1, bd2);
    const double d21_rg2_bd1 = bddist(rgvec2, bd1);

    // -------- Initial direct "through boundary" estimate --------
    double best = dist;

    {
        const double abs_d11 = std::fabs(d11_0);
        const double abs_d22 = std::fabs(d22_0);

        const double tunnel =
            std::min(
                std::min(
                    std::min(guncpmdist(pg1,  pg2),
                             guncpmdist(pg1,  mpg2)),
                    guncpmdist(mpg1, pg2)),
                guncpmdist(mpg1, mpg2));

        const double trial = abs_d11 + abs_d22 + tunnel;
        if (trial < best) best = trial;
    }

    // -------- Pointer tables for the 4 reflection choices --------
    const double* rgv1[4] = { gvec1, gvec1, rgvec1, rgvec1 };
    const double* rgv2[4] = { gvec2, rgvec2, rgvec2, gvec2 };

    // d11: ±d11_0
    const double d11[4] = {  d11_0,  d11_0, -d11_0, -d11_0 };

    // d12: depends on reflection of g1
    const double d12[4] = {
        d12_0,
        d12_0,
        d12_rg1_bd2,
        d12_rg1_bd2
    };

    // d21: depends on reflection of g2
    const double d21[4] = {
        d21_0,
        d21_rg2_bd1,
        d21_rg2_bd1,
        d21_0
    };

    // d22: ±d22_0
    const double d22[4] = {  d22_0, -d22_0, -d22_0,  d22_0 };

    // -------- Segment distances (true distances, not squared) --------
    double dg1g2[4];
    dg1g2[0] = CNCM_gdist(gvec1, gvec2);
    dg1g2[1] = CNCM_gdist(gvec1, rgvec2);
    dg1g2[2] = CNCM_gdist(rgvec1, rgvec2);
    dg1g2[3] = CNCM_gdist(rgvec1, gvec2);

    // -------- Loop over the 4 sign combinations --------
    for (int jj = 0; jj < 4; ++jj)
    {
        const double d11j = d11[jj];
        const double d12j = d12[jj];
        const double d21j = d21[jj];
        const double d22j = d22[jj];

        // Prune combinations where both endpoints lie clearly
        // on the same side of their boundaries.
        if (d11j * d21j > EPS_SIGN || d22j * d12j > EPS_SIGN)
            continue;

        const double ad11 = std::fabs(d11j);
        const double ad22 = std::fabs(d22j);
        const double ad21 = std::fabs(d21j);
        const double ad12 = std::fabs(d12j);

        // Compute interpolation parameters
        double alpha1 = 0.0;
        if (ad11 >= EPS_SIGN)
            alpha1 = std::min(1.0, ad11 / (EPS_SIGN + ad11 + ad21));

        double alpha2 = 0.0;
        if (ad22 >= EPS_SIGN)
            alpha2 = std::min(1.0, ad22 / (EPS_SIGN + ad22 + ad12));

        const double* rv1 = rgv1[jj];
        const double* rv2 = rgv2[jj];

        // Interpolate along the segment between rv1 and rv2
        double bdint1[6], bdint2[6];
        for (int i = 0; i < 6; ++i) {
            const double diff = rv2[i] - rv1[i];
            bdint1[i] = rv1[i] + alpha1 * diff;
            bdint2[i] = rv2[i] - alpha2 * diff;
        }

        // Apply integer mapping matrices
        double mbdint1[6], mbdint2[6];
        imv6(bdint1, MS[bd1], mbdint1);
        imv6(bdint2, MS[bd2], mbdint2);

        // s1: contribution from the first side
        double s1 = alpha1 * dg1g2[jj];
        s1 = std::min(s1, CNCM_gdist(rv1, mbdint1));
        s1 = std::min(s1, ad11 + guncpmdist(mpg1, bdint1));
        s1 = std::min(s1, ad11 + guncpmdist(mpg1, mbdint1));
        if (s1 > best) continue; // cannot beat current best

        // s2: contribution from the second side
        double s2 = alpha2 * dg1g2[jj];
        s2 = std::min(s2, CNCM_gdist(rv2, mbdint2));
        s2 = std::min(s2, ad22 + guncpmdist(mpg2, bdint2));
        s2 = std::min(s2, ad22 + guncpmdist(mpg2, mbdint2));
        if (s1 + s2 > best) continue;

        // Middle connector distance between the two boundary points
        const double mid =
            std::min(
                std::min(
                    guncpmdist(bdint1, bdint2),
                    guncpmdist(bdint1, mbdint2)),
                std::min(
                    guncpmdist(mbdint1, bdint2),
                    guncpmdist(mbdint1, mbdint2)));

        const double trial = s1 + s2 + mid;
        if (trial < best) best = trial;
    }

    return best;
}

constexpr double DCUT = 0.9995;
inline double fudge(double d) { return DCUT * d; }

/*
     Compute the CNCM_minimal distance between two Niggli-reduced
     vectors in the Niggli Cone following the embedding paths
     to the 15 boundaries
 */

// ---------------------------------------------------------------------------
// NCDistWorkspace – reusable scratch for NCDist / NCDist_pass
// ---------------------------------------------------------------------------

struct NCDistWorkspace
{
  // Scratch for boundary maps / NCDist_pass
   double dists1[NBND];
   double pgs1[NBND][6], rgs1[NBND][6], mpgs1[NBND][6], mvecs1[NBND][6];
   double dists2[NBND];
   double pgs2[NBND][6], rgs2[NBND][6], mpgs2[NBND][6], mvecs2[NBND][6];
   int iord1[NBND], iord2[NBND];


  // Scratch for outer reflection passes (full NCDist)
   double ndist1[NREFL];
   double ndist2[NREFL];
   int opass, ir, irt;
   int rpasses;
   double rgvec1[NREFL][6];
   double rgvec2[NREFL][6];

  NCDistWorkspace() = default;

  // One pass with all boundaries (formerly free NCDist_pass)
  double NCDist_pass(const double gvec1[6], const double gvec2[6], double dist)
  {
    const double mindists1 = minbddist(gvec1);
    const double mindists2 = minbddist(gvec2);

    if (mindists1 > dist || mindists2 > dist) return dist;

    // Early exit: even the best two-boundary path cannot beat current dist
    if (mindists1 + mindists2 > dist) return dist;

    double maxdist = fudge(dist);

    if (mindists1 + mindists2 < maxdist)
    {
      int ngood1 = 0, ngood2 = 0;

      // Fill boundary maps and projected / mapped vectors
      bdmaps(gvec1, dists1, iord1, pgs1, rgs1, mpgs1, mvecs1, maxdist, &ngood1);
      bdmaps(gvec2, dists2, iord2, pgs2, rgs2, mpgs2, mvecs2, maxdist, &ngood2);

      const int signgvec1p = CNCM_vtoppp(gvec1);
      const int signgvec1m = CNCM_vtommm(gvec1);
      const int signgvec2p = CNCM_vtoppp(gvec2);
      const int signgvec2m = CNCM_vtommm(gvec2);

      // ---------------------------------------------------------------
      // One-side boundary paths starting from gvec1
      // ---------------------------------------------------------------
      for (int jx1 = 0; jx1 < ngood1; ++jx1)
      {
        const int j1 = iord1[jx1];
        const double d1 = dists1[j1];
        const int signpg1p = CNCM_vtoppp(pgs1[j1]);
        const int signpg1m = CNCM_vtommm(pgs1[j1]);
        const int signmpg1p = CNCM_vtoppp(mpgs1[j1]);
        const int signmpg1m = CNCM_vtommm(mpgs1[j1]);

        if (d1 < maxdist && d1 < dist &&
            ((ispbd[j1] && signgvec1p > 0) || (ismbd[j1] && signgvec1m < 0)) &&
            ((ispbd[j1] && signpg1p > 0) || (ismbd[j1] && signpg1m < 0)) &&
            ((ispmappedbd[j1] && signmpg1p > 0) ||
             (ismmappedbd[j1] && signmpg1m < 0)))
        {
          const double cand = guncpmdist(gvec2, mpgs1[j1]) + d1;
          if (cand < dist) dist = cand;
        }
      }

      // ---------------------------------------------------------------
      // One-side boundary paths starting from gvec2
      // ---------------------------------------------------------------
      for (int jx2 = 0; jx2 < ngood2; ++jx2)
      {
        const int j2 = iord2[jx2];
        const double d2 = dists2[j2];

        const int signpg2p = CNCM_vtoppp(pgs2[j2]);
        const int signpg2m = CNCM_vtommm(pgs2[j2]);
        const int signmpg2p = CNCM_vtoppp(mpgs2[j2]);
        const int signmpg2m = CNCM_vtommm(mpgs2[j2]);

        if (d2 < maxdist && d2 < dist &&
            ((ispbd[j2] && signgvec2p > 0) || (ismbd[j2] && signgvec2m < 0)) &&
            ((ispbd[j2] && signpg2p > 0) || (ismbd[j2] && signpg2m < 0)) &&
            ((ispmappedbd[j2] && signmpg2p > 0) ||
             (ismmappedbd[j2] && signmpg2m < 0)))
        {
          const double cand = guncpmdist(gvec1, mpgs2[j2]) + d2;
          if (cand < dist) dist = cand;
        }
      }

      // Update maxdist now that dist may have improved
      maxdist = fudge(dist);

      // ---------------------------------------------------------------
      // Double-boundary “reflection” paths
      // ---------------------------------------------------------------
      for (int jx1 = 0; jx1 < ngood1; ++jx1)
      {
        const int j1 = iord1[jx1];
        const double d1 = dists1[j1];

        if (d1 < maxdist && d1 < dist &&  // AJM
            ((ispbd[j1] && signgvec1p > 0) || (ismbd[j1] && signgvec1m < 0)))
        {
          for (int jx2 = 0; jx2 < ngood2; ++jx2)
          {
            const int j2 = iord2[jx2];
            const double d2 = dists2[j2];

            if (d2 < maxdist && d2 < dist &&  // AJM
                ((ispbd[j2] && signgvec2p > 0) ||
                 (ismbd[j2] && signgvec2m < 0)))
            {
              dist =
                  NCDist_2bds(gvec1, rgs1[j1], pgs1[j1], mpgs1[j1], j1, gvec2,
                              rgs2[j2], pgs2[j2], mpgs2[j2], j2, dist);
            }
          }
        }
      }
    }

    return dist;
  }

  // ---------------------------------------------------------
  // Serial version of the reflection passes (same logic as worker_loop)
  // ---------------------------------------------------------
  double NCDist_reflections_serial(const double gvec1[6], const double gvec2[6],
                                   int rpasses, double base_dist)
  {
    double local_min = base_dist;

    const double md_g1 = minbddist(gvec1);
    const double md_g2 = minbddist(gvec2);
    const int s1p = CNCM_vtoppp(gvec1);
    const int s1m = CNCM_vtommm(gvec1);
    const int s2p = CNCM_vtoppp(gvec2);
    const int s2m = CNCM_vtommm(gvec2);

    for (int irt = 0; irt < rpasses; ++irt)
    {
      const int ir = rord[irt];
      if (ir == 0) continue;

      double rg1[6];
      imv6(gvec1, RS[ir], rg1);

      // --- (1) Boundary lower bound pruning ---
      {
        double md1_ref = minbddist(rg1);
        if (md1_ref + md_g2 >= local_min) goto reflect_g2;
      }

      // --- (2) Sign invariance pruning ---
      {
        int sr1p = CNCM_vtoppp(rg1);
        int sr1m = CNCM_vtommm(rg1);
        if (s1p == sr1p && s1m == sr1m) goto reflect_g2;
      }

      // --- (3) Euclidean G6 lower bound ---
      {
        double d6 = g456distsq(rg1, gvec2);
        if (d6 >= local_min) goto reflect_g2;
      }

      // --- Evaluate reflected gvec1 ---
      {
        double d1 = NCDist_pass(rg1, gvec2, local_min);
        if (d1 < local_min) local_min = d1;
      }

    reflect_g2:
      double rg2[6];
      imv6(gvec2, RS[ir], rg2);

      // --- (1) Boundary lower bound pruning ---
      {
        double md2_ref = minbddist(rg2);
        if (md_g1 + md2_ref >= local_min) continue;
      }

      // --- (2) Sign invariance pruning ---
      {
        int sr2p = CNCM_vtoppp(rg2);
        int sr2m = CNCM_vtommm(rg2);
        if (s2p == sr2p && s2m == sr2m) continue;
      }

      // --- (3) Euclidean G6 lower bound ---
      {
        double d6 = g456distsq(gvec1, rg2);
        if (d6 >= local_min) continue;
      }

      // --- Evaluate reflected gvec2 ---
      {
        double d2 = NCDist_pass(gvec1, rg2, local_min);
        if (d2 < local_min) local_min = d2;
      }
    }

    return local_min;
  }

  // Full NCDist including outer reflection passes
  // Full NCDist including outer reflection passes
  double compute(const double gvec1[6], const double gvec2[6])
  {
    double dist1 = minbddist(gvec1);
    double dist2 = minbddist(gvec2);
    std::min(dist1, dist2);  // left as in original

    int rpasses = NREFL_OUTER_MIN;

    double dist = guncpmdist(gvec1, gvec2);
    dist = NCDist_pass(gvec1, gvec2, dist);

    if (dist1 + dist2 < dist * 0.5) rpasses = NREFL_OUTER_FULL;

    if (rpasses > 0)
    {
      // Run the reflection passes *serially* inside this workspace
      dist = NCDist_reflections_serial(gvec1, gvec2, rpasses, dist);
    }

    return dist;
  }
};

inline double NCDist(const double *g1, const double *g2)
{
  thread_local NCDistWorkspace ws;

  double v1[6], v2[6];
  // Load into Vec6 in tight unrolled loop
  for (int i = 0; i < 6; ++i)
  {
    v1[i] = g1[i];
    v2[i] = g2[i];
  }
  return ws.compute(v1, v2);
}
} // namespace phasertng
#endif /* NCDIST_H_MCCOLL */
