#ifndef R9DIST
#define R9DIST

#include <iomanip>
#include <iostream>
#include <math.h>
#include <float.h>


//static int RS[NREFL][36] = {
//   /*  R_0:M_ident;     */
//   {1,0,0,0,0,0,
//    0,1,0,0,0,0,
//    0,0,1,0,0,0,
//    0,0,0,1,0,0,
//    0,0,0,0,1,0,
//    0,0,0,0,0,1},
//    /*  R_1:M_1;         */
//    {0,1,0,0,0,0,
//     1,0,0,0,0,0,
//     0,0,1,0,0,0,
//     0,0,0,0,1,0,
//     0,0,0,1,0,0,
//     0,0,0,0,0,1},
//     /*  R_2:M_2;         */
//     {1,0,0,0,0,0,
//      0,0,1,0,0,0,
//      0,1,0,0,0,0,
//      0,0,0,1,0,0,
//      0,0,0,0,0,1,
//      0,0,0,0,1,0},
//      /*  R_3:M_2.M_1;     */
//      {0,1,0,0,0,0,
//       0,0,1,0,0,0,
//       1,0,0,0,0,0,

#define NREFL 24

static int RS_R9[NREFL][81] = {
   // 1. Identity
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,1,0, 0,0,0,0,0,0,0,0,1},

   // 2. Swap s0 and s1
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,-1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,0,1,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,1},

   // 3. Swap s0 and s2
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,-1,-1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,0,0,1, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,1,0},

   // 4. Swap s1 and s2
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,-1,0,0,0,0,0, 0,0,0,-1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,1,0},

   // 5. Swap s3 and s4
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,-1,1,0,0,0, 0,0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,1,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,1},

   // 6. Swap s3 and s5
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,-1,-1,0,0,0, 0,0,0,0,0,0,0,0,1, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,1,0},

   // 7. Swap s4 and s5
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,-1,0,0,0, 0,0,0,0,0,-1,0,0,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,1,0},

   // 8. Swap s0 and s3
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,-1,0,0, 0,0,0,0,0,0,0,1,0, 0,0,0,0,0,0,0,0,1},

   // 9. Swap s0 and s4
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,0,-1,0, 0,0,0,0,0,0,-1,0,0, 0,0,0,0,0,0,0,0,1},

   // 10. Swap s0 and s5
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,0,0,-1, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,-1,0,0},

   // 11. Swap s1 and s3
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,0,1,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,1},

   // 12. Swap s1 and s4
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,-1,0, 0,0,0,0,0,0,0,0,1},

   // 13. Swap s1 and s5
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,-1, 0,0,0,0,0,0,0,-1,0},

   // 14. Swap s2 and s3
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,0,0,1, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,1,0,0},

   // 15. Swap s2 and s4
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,1,0},

   // 16. Swap s2 and s5
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,1,0, 0,0,0,0,0,0,0,0,-1},

   // 17. Swap (s0,s1) and (s3,s4)
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,-1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0,0, 0,0,0,0,-1,1,0,0,0, 0,0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,-1,0, 0,0,0,0,0,0,-1,0,0, 0,0,0,0,0,0,0,0,1},

   // 18. Swap (s0,s2) and (s3,s5)
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,-1,-1,0,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,-1,-1,0,0,0, 0,0,0,0,0,0,0,0,-1, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,-1,0,0},

   // 19. Swap (s0,s1,s2) and (s3,s4,s5) cyclically
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,-1,-1,0,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,-1,-1,0,0,0, 0,0,0,0,0,0,0,1,0, 0,0,0,0,0,0,0,0,1, 0,0,0,0,0,0,1,0,0},

   // 20. Swap (s0,s2,s1) and (s3,s5,s4) cyclically
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,0,-1,0,0,0,0,0, 0,0,1,-1,0,0,0,0,0, 0,0,0,0,0,-1,0,0,0, 0,0,0,0,1,-1,0,0,0, 0,0,0,0,0,0,0,0,1, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,1,0},

   // 21. Swap s0 and s3, s1 and s5, s2 and s4
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,-1,0,0, 0,0,0,0,0,0,0,0,-1, 0,0,0,0,0,0,0,-1,0},

   // 22. Swap s0 and s4, s1 and s3, s2 and s5
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,0,-1,0,0,0,0,0, 0,0,-1,0,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,0,-1,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,-1},

   // 23. Swap s0 and s5, s1 and s4, s2 and s3
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,0,0,-1, 0,0,0,0,0,0,0,-1,0, 0,0,0,0,0,0,-1,0,0},

   // 24. Identity (invert all swaps for even number of swaps)
   {1,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0,0, 0,0,0,0,1,0,0,0,0, 0,0,0,0,0,1,0,0,0, 0,0,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,1,0, 0,0,0,0,0,0,0,0,1}
};

//R9 MV(const double* m, const double* v)
//{
//   R9 out;
//   for (size_t i = 0; i < 9; ++i) {
//      double sum = 0;
//      for (size_t kk = 9 * i; kk < 9 * i + 9; ++kk) {
//         sum += v[i] * m[kk];
//      }
//      out[i] = sum;
//   }
//   return out;
//}

static void imv9(double v1[9], int m[81], double v2[9]) {
   int i, j;
   double sum;
   for (i = 0; i < 9; i++) {
      sum = 0.0;
      for (j = 0; j < 9; j++) {
         sum = sum + ((double)m[9 * i + j]) * v1[j];
      }
      v2[i] = sum;
   }
}

static void r9_diff(double* r1, double* r2, double* diff) {
   for (size_t i = 0; i < 9; ++i) {
      diff[i] = r1[i] - r2[i];
   }
}

static double norm(double* r) {
   double sum;
   sum = 0;
   for (size_t i = 0; i < 9; ++i) {
      sum += r[i]*r[i];
   }
   return sqrt(sum);
}

//
//double r9_lattice_distance(double r9_1[9], double r9_2[9]) {
//   double min_distance = DBL_MAX;
//
//   //std::cout << "r9_1 ";
//   //for (size_t i = 0; i < 9; ++i) {
//   //   std::cout << r9_1[i] << " ";
//   //}
//   //std::cout << std::endl;
//
//   //std::cout << "r9_2 ";
//   //for (size_t i = 0; i < 9; ++i) {
//   //   std::cout << r9_2[i] << " ";
//   //}
//   //std::cout << std::endl;
//
//   double permuted[9];
//   for (size_t i = 0; i < 24; ++i) {
//      imv9(r9_1 , RS[i], permuted);
//
//      //std::cout << i << " permuted ";
//      //for (size_t i = 0; i < 9; ++i) {
//      //   std::cout << permuted[i] << " ";
//      //}
//      //std::cout << std::endl;
//
//
//      double diff[9];
//      r9_diff(permuted, r9_2, diff);
//
//      //std::cout << i << " r9_diff ";
//      //for (size_t i = 0; i < 9; ++i) {
//      //   std::cout << diff[i] << " ";
//      //}
//      //std::cout << std::endl;
//      double distance = norm(diff);
//      if (distance < min_distance) min_distance = distance;
//   }
//   return min_distance;
//}
static double r9_lattice_distance(double r9_1[9], double r9_2[9]) {
   double min_distance = DBL_MAX;
   std::cout << std::setprecision(6) << std::fixed;
   //std::cout << "r9_1: ";
   //for (size_t i = 0; i < 9; ++i) {
   //   std::cout << r9_1[i] << " ";
   //}
   //std::cout << std::endl;
   //std::cout << "r9_2: ";
   //for (size_t i = 0; i < 9; ++i) {
   //   std::cout << r9_2[i] << " ";
   //}
   //std::cout << std::endl;

   double permuted[9];
   for (size_t i = 0; i < 24; ++i) {
      imv9(r9_1, RS_R9[i], permuted);
      //std::cout << "Permutation " << i << ": ";
      //for (size_t j = 0; j < 9; ++j) {
      //   std::cout << permuted[j] << " ";
      //}
      //std::cout << std::endl;

      double diff[9];
      r9_diff(permuted, r9_2, diff);
      double distance = norm(diff);
      //std::cout << "Distance: " << distance << std::endl;

      if (distance < min_distance) {
         min_distance = distance;
         //std::cout << "New minimum distance: " << min_distance << std::endl;
      }
   }
   return min_distance;
}

static double R9Dist(double* r1, double* r2) {
   return r9_lattice_distance(r1, r2);
}



#endif // R9DIST
